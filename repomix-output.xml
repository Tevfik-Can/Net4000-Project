This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
analysis/simple_test.py
data_collection/client.py
data_collection/fast_server.py
docs/PROJECT.md
ebpf_programs/ebpf_net.c
ebpf_programs/ebpf_runner.py
ebpf_programs/ebpf_runner2.py
ebpf_programs/ebpf-probe.c
ebpf_programs/gitignore.txt
ebpf_programs/readme.txt
ebpf_programs/requirements.txt
ebpf_programs/vmlinux.h
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# IDE files
.idea/
.vscode/
*.swp
*.swo

# Backup directories
backup_works/

# Results data
results/
!results/README.md

# Python cache
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
dist/
*.egg-info/

# Virtual environments
venv/
env/

# System files
.DS_Store
Thumbs.db

# Logs and temporary files
*.log
*.tmp
*.temp

# Large data files
*.json
*.csv
*.pkl
</file>

<file path="analysis/simple_test.py">
#!/usr/bin/env python3
import time
import threading
import requests
import json
from http.server import HTTPServer, BaseHTTPRequestHandler
from bcc import BPF

# -------------------------------
# eBPF program (TCP events)
# -------------------------------
bpf_program = """
#include <uapi/linux/ptrace.h>
#include <linux/sched.h>
#include <bcc/proto.h>

#define EVT_CONNECT 1
#define EVT_SEND    2
#define EVT_RECV    3
#define EVT_CLOSE   4

struct net_event_t {
    u64 ts_ns;
    u32 pid;
    u32 ppid;
    u32 bytes;
    u8  event_type;
    char comm[TASK_COMM_LEN];
};

BPF_PERF_OUTPUT(events);

static __always_inline int submit_event(
    struct pt_regs *ctx,
    u8 event_type,
    u32 bytes
) {
    struct net_event_t e = {};
    struct task_struct *task;

    e.ts_ns = bpf_ktime_get_ns();
    e.pid = bpf_get_current_pid_tgid() >> 32;

    task = (struct task_struct *)bpf_get_current_task();
    e.ppid = task->real_parent->tgid;

    e.bytes = bytes;
    e.event_type = event_type;
    bpf_get_current_comm(&e.comm, sizeof(e.comm));

    events.perf_submit(ctx, &e, sizeof(e));
    return 0;
}

int kprobe__tcp_v4_connect(struct pt_regs *ctx) { return submit_event(ctx, EVT_CONNECT, 0); }
int kprobe__tcp_sendmsg(struct pt_regs *ctx)   { u32 size = (u32)PT_REGS_PARM3(ctx); return submit_event(ctx, EVT_SEND, size); }
int kprobe__tcp_recvmsg(struct pt_regs *ctx)   { u32 size = (u32)PT_REGS_PARM3(ctx); return submit_event(ctx, EVT_RECV, size); }
int kprobe__tcp_close(struct pt_regs *ctx)     { return submit_event(ctx, EVT_CLOSE, 0); }
"""

# Mapping numeric codes to human-readable words
EVENT_TYPE_MAP = {
    1: "connect",
    2: "send",
    3: "recv",
    4: "close"
}

# -------------------------------
# HTTP Server
# -------------------------------
def run_server():
    class Handler(BaseHTTPRequestHandler):
        def do_GET(self):
            self.send_response(200)
            self.end_headers()
            self.wfile.write(b"OK")
        def log_message(self, *args): pass

    server = HTTPServer(("127.0.0.1", 8080), Handler)
    threading.Thread(target=server.serve_forever, daemon=True).start()
    return server

# -------------------------------
# Client Requests
# -------------------------------
def run_client_requests(num_requests=10):
    metrics = []
    for i in range(num_requests):
        start = time.time()
        try:
            r = requests.get("http://127.0.0.1:8080", timeout=2)
            latency = (time.time() - start) * 1000
            metrics.append({
                "request_id": i + 1,
                "latency_ms": latency,
                "status_code": r.status_code,
                "success": r.status_code == 200
            })
        except Exception as e:
            latency = (time.time() - start) * 1000
            metrics.append({
                "request_id": i + 1,
                "latency_ms": latency,
                "status_code": None,
                "success": False,
                "error": str(e)
            })
        time.sleep(0.1)
    return metrics

# -------------------------------
# Main
# -------------------------------
def main():
    print("=== Starting HTTP Server ===")
    server = run_server()
    time.sleep(1)  # let server start

    print("=== Loading eBPF program ===")
    b = BPF(text=bpf_program, debug=0)  # suppress warnings

    # Collect eBPF events
    ebpf_events = []

    def handle_event(cpu, data, size):
        e = b["events"].event(data)
        ebpf_events.append({
            "timestamp_ns": e.ts_ns,
            "pid": e.pid,
            "ppid": e.ppid,
            "bytes": e.bytes,
            "event_type": EVENT_TYPE_MAP.get(e.event_type, "unknown"),
            "comm": e.comm.decode(errors="replace")
        })

    b["events"].open_perf_buffer(handle_event)

    # BPF polling thread
    stop_bpf = False
    def poll_bpf():
        while not stop_bpf:
            b.perf_buffer_poll(timeout=100)

    t = threading.Thread(target=poll_bpf)
    t.start()

    # Send HTTP requests
    print("=== Sending HTTP requests ===")
    request_metrics = run_client_requests(num_requests=10)

    # Give BPF a short moment to catch remaining events
    time.sleep(0.5)
    stop_bpf = True
    t.join()

    # Shutdown server
    server.shutdown()
    server.server_close()

    # Compute average latency
    avg_latency = sum(m["latency_ms"] for m in request_metrics) / len(request_metrics)

    # Save results
    output = {
        "application_metrics": request_metrics,
        "ebpf_events": ebpf_events,
        "summary": {
            "total_requests": len(request_metrics),
            "successful_requests": len([m for m in request_metrics if m["success"]]),
            "avg_latency_ms": avg_latency,
            "total_ebpf_events": len(ebpf_events)
        }
    }

    with open("tcp_events_output.json", "w") as f:
        json.dump(output, f, indent=2)

    print("\n=== Summary ===")
    print(f"HTTP requests sent: {len(request_metrics)}")
    print(f"Successful requests: {len([m for m in request_metrics if m['success']])}")
    print(f"Average latency: {avg_latency:.2f} ms")
    print(f"TCP events captured by eBPF: {len(ebpf_events)}")
    print("Detailed events exported to tcp_events_output.json")

if __name__ == "__main__":
    main()
</file>

<file path="data_collection/client.py">
import requests
import time
import json
import sys

SERVER_URL = "http://127.0.0.1:8080"
REQUEST_INTERVAL_MS = 200
TIMEOUT_MS = 5000
metrics = []
request_id = 0

while True:
    request_id += 1
    start_time = time.time()
    try:
        response = requests.get(
            SERVER_URL,
            timeout=TIMEOUT_MS / 1000.0
        )
        end_time = time.time()
        latency_ms = (end_time - start_time) * 1000
        result = "success"
        status_code = response.status_code
    except requests.exceptions.Timeout:
        end_time = time.time()
        latency_ms = (end_time - start_time) * 1000
        result = "timeout"
        status_code = None
    except Exception as e:
        end_time = time.time()
        latency_ms = (end_time - start_time) * 1000
        result = f"error: {str(e)}"
        status_code = None
    
    metric = {
        "request_id": request_id,
        "start_time": start_time,
        "end_time": end_time,
        "latency_ms": latency_ms,
        "result": result,
        "status_code": status_code
    }
    metrics.append(metric)
    
    # Print progress to stderr (not part of JSON output)
    print(f"Request {request_id}: {latency_ms:.2f} ms - {result}", file=sys.stderr)
    time.sleep(REQUEST_INTERVAL_MS / 1000.0)
    
    if request_id == 10:
        break

# Output only JSON to stdout
print(json.dumps(metrics, indent=2))
</file>

<file path="data_collection/fast_server.py">
#!/usr/bin/env python3
"""
Fast HTTP server for testing
"""
from http.server import HTTPServer, BaseHTTPRequestHandler
import time

class FastHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header('Content-type', 'text/plain')
        self.send_header('Connection', 'close')
        self.end_headers()
        self.wfile.write(b"OK")
    
    def log_message(self, format, *args):
        # Minimal logging
        pass

def run_server(port=8080):
    server = HTTPServer(('0.0.0.0', port), FastHandler)
    print(f"Fast server listening on port {port}")
    print("Press Ctrl+C to stop")
    server.serve_forever()

if __name__ == '__main__':
    run_server()
</file>

<file path="docs/PROJECT.md">
# Cross-Layer Network Observability Project

## Structure
- `data_collection/` - HTTP client/server for application metrics
- `analysis/` - Test scripts and data analysis
- `ebpf_programs/` - eBPF headers and programs
- `results/` - Output data (gitignored)

## Quick Test
```bash
cd analysis
python3 simple_test.py
</file>

<file path="ebpf_programs/ebpf_net.c">
#include <uapi/linux/ptrace.h>
#include <linux/sched.h>
#include <bcc/proto.h>

#define EVT_CONNECT 1
#define EVT_SEND    2
#define EVT_RECV    3
#define EVT_CLOSE   4

struct net_event_t {
    u64 ts_ns;
    u32 pid;
    u32 ppid;
    u32 bytes;
    u8  event_type;
    char comm[TASK_COMM_LEN];
};

BPF_PERF_OUTPUT(events);

/* Optional: filter to specific PIDs */
BPF_HASH(target_pids, u32, u8);

static __always_inline int submit_event(
    struct pt_regs *ctx,
    u8 event_type,
    u32 bytes
) {
    struct net_event_t e = {};
    struct task_struct *task;

    e.ts_ns = bpf_ktime_get_ns();
    e.pid = bpf_get_current_pid_tgid() >> 32;

    task = (struct task_struct *)bpf_get_current_task();
    e.ppid = task->real_parent->tgid;

    e.bytes = bytes;
    e.event_type = event_type;
    bpf_get_current_comm(&e.comm, sizeof(e.comm));

    events.perf_submit(ctx, &e, sizeof(e));
    return 0;
}
/* Connection start */
int kprobe__tcp_v4_connect(struct pt_regs *ctx) {
    return submit_event(ctx, EVT_CONNECT, 0);
}

/* Data sent */
int kprobe__tcp_sendmsg(struct pt_regs *ctx) {
    u32 size = (u32)PT_REGS_PARM3(ctx);
    return submit_event(ctx, EVT_SEND, size);
}

/* Data received */
int kprobe__tcp_recvmsg(struct pt_regs *ctx) {
    u32 size = (u32)PT_REGS_PARM3(ctx);
    return submit_event(ctx, EVT_RECV, size);
}

/* Connection close */
int kprobe__tcp_close(struct pt_regs *ctx) {
    return submit_event(ctx, EVT_CLOSE, 0);
}
</file>

<file path="ebpf_programs/ebpf_runner.py">
#!/usr/bin/env python3
from bcc import BPF
from pathlib import Path

def process_event(cpu, data, size):
	event = bpf["events"].event(data)
	print(f"Process {event.comm.decode()} (PID: {event.pid}, PPID: n{event.ppid}) called sys_clone")
bpf_source = Path('ebpf-probe.c').read_text()
bpf = BPF(text=bpf_source)

bpf["events"].open_perf_buffer(process_event)

print("Monitoring")
while True:
	try:
		bpf.perf_buffer_poll()
	except KeyboardInterrupt:
		break
</file>

<file path="ebpf_programs/ebpf_runner2.py">
#!/usr/bin/env python3
from bcc import BPF
import ctypes
import time

EVENT_NAMES = {
    1: "CONNECT",
    2: "SEND",
    3: "RECV",
    4: "CLOSE",
}

bpf = BPF(src_file="ebpf_net.c")

# Add PIDs you want to monitor
# (server + client)
import os
server_pid = int(os.environ.get("SERVER_PID", "0"))
client_pid = int(os.environ.get("CLIENT_PID", "0"))

if server_pid:
    bpf["target_pids"][ctypes.c_uint(server_pid)] = ctypes.c_ubyte(1)

if client_pid:
    bpf["target_pids"][ctypes.c_uint(client_pid)] = ctypes.c_ubyte(1)

class Event(ctypes.Structure):
    _fields_ = [
        ("ts_ns", ctypes.c_ulonglong),
        ("pid", ctypes.c_uint),
        ("ppid", ctypes.c_uint),
        ("bytes", ctypes.c_uint),
        ("event_type", ctypes.c_ubyte),
        ("comm", ctypes.c_char * 16),
    ]

def handle_event(cpu, data, size):
    e = ctypes.cast(data, ctypes.POINTER(Event)).contents
    print(
        f"{e.ts_ns} | "
        f"{EVENT_NAMES.get(e.event_type)} | "
        f"PID={e.pid} ({e.comm.decode()}) | "
        f"bytes={e.bytes}"
    )

bpf["events"].open_perf_buffer(handle_event)

print("Monitoring TCP activity (Ctrl-C to stop)...")

while True:
    try:
        bpf.perf_buffer_poll()
    except KeyboardInterrupt:
        break
</file>

<file path="ebpf_programs/ebpf-probe.c">
#include <uapi/linux/ptrace.h>
#include <linux/sched.h> 
#include <bcc/proto.h> 
struct data_t{ 
	u32 pid;
 	u32 ppid; 
	char comm[TASK_COMM_LEN]; 
}; 
BPF_PERF_OUTPUT(events);
int kprobe__sys_clone(void *ctx){ 
	struct data_t data = {};
 	struct task_struct *task;
	 task = (struct task_struct *)bpf_get_current_task(); 
	data.pid = bpf_get_current_pid_tgid(); 
	data.ppid = task->real_parent->tgid; 
	bpf_get_current_comm(&data.comm, sizeof(data.comm));
	 events.perf_submit(ctx, &data, sizeof(data)); 
	return 0; //bpf_trace_printk("hello, world\\n"); //return 0; }
}
</file>

<file path="ebpf_programs/gitignore.txt">
# IDE files
.idea/
.vscode/
*.swp
*.swo

# Backup directories
backup_works/

# Results data
results/
!results/README.md

# Python cache
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
dist/
*.egg-info/

# Virtual environments
venv/
env/

# System files
.DS_Store
Thumbs.db

# Logs and temporary files
*.log
*.tmp
*.temp

# Large data files
*.json
*.csv
*.pkl
</file>

<file path="ebpf_programs/readme.txt">
ebpf probe file is to be used alongside the runner1,
it is a very basic program that tracks all kernel events unconditionally

ebpf net file is to be ran with the runner2,
this focuses specifically on the kernel tcp events

the simple test file runs and uses the code from the net file
</file>

<file path="ebpf_programs/requirements.txt">
requests>=2.31.0
matplotlib>=3.7.0
pandas>=2.0.0
numpy>=1.24.0
</file>

<file path="ebpf_programs/vmlinux.h">

</file>

</files>
